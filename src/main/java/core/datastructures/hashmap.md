# HashMap

Реализация ассоциативного массива (dictionary, map, hash, table)

Хранит ключ - значение, позволяет в среднем за О(1) делать
- put
- get
- remove

### Ключевой принцип:
быстро вычисление позиции в памяти по хешу ключа - хранение данных в бакетах (buckets)

### Применение:
- кэширование
- lookups по ID
- быстрые мапы DTO
- реестр бинов
- почти во всех core-системах Java

### Архитектура:
- `transient Node<K,V>[] table;` - массив
- `int threshold;`
- `transient int size;`
- `transient Set<Map.Entry<K,V>> entrySet;`
- `final float loadFactor;`
- `transient int modCount;`
- `putVal(hash(key), key, value, false, evict);`
- `if (table == null || table.length == 0)
  table = resize();`
- `Node<K,V>[] newTab = (Node<K,V>[]) new Node[DEFAULT_INITIAL_CAPACITY];
  По умолчанию:
  DEFAULT_INITIAL_CAPACITY = 16,
  loadFactor = 0.75,
  → threshold = 16 * 0.75 = 12.`
- 

### Механика работы:
1) каждый объект в HashMap имеет свой уникальный ключ
2) при добавлении элемента в HashMap вычисляется хэш-код КЛЮЧА с помошью метода hashCode() у ключа
3) для каждого хэш-кода вычисляется индекс массива, где будет храниться значение
4) если 2 ключа имеют одинаковых хэш-код, они могут быть сохранены в одной ячейке массива, но будут храниться в ОДНОСВЯЗНОМ списке в этой ячейке
5) когда происходит запрос на получение значения по ключу, сначала вычисляется хэш-код ключа, затем определяется индекс массива, где может быть найдено значение. Если в этой ячейке есть список, пробегаем по списку, чтобьы найти нужное значение
6) при использовании HashMap необходимо правильно переопределить методы equals() и hashCode() класса ключа, чтобы обеспечить правильно функционирование хэш-таблицы
7) когда количество элементов в HashMap достигает определенного порога, размер массива увеличивается автоматически для поддержания эффективности хранения и доступа к данным

table[5] ─► Node(hash=123, key="cat", val=1) ─► Node(hash=567, key="dog", val=2) ─► null
